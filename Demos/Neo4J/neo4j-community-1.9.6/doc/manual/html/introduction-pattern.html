<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.5. Patterns</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The Neo4j Manual v1.9.6" /><link rel="up" href="query-syntax.html" title="Chapter 11. Syntax" /><link rel="prev" href="cypher-comments.html" title="11.4. Comments" /><link rel="next" href="query-read.html" title="Chapter 12. Reading Clauses" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 4. Using Neo4j embedded in Java applications" /><link rel="chapter" href="tutorials-rest.html" title="Chapter 5. Neo4j Remote Client Libraries" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 6. The Traversal Framework" /><link rel="chapter" href="data-modeling-examples.html" title="Chapter 7. Data Modeling Examples" /><link rel="chapter" href="languages.html" title="Chapter 8. Languages" /><link rel="chapter" href="server-extending.html" title="Chapter 9. Extending the Neo4j Server" /><link rel="part" href="cypher-query-lang.html" title="Part III. Cypher Query Language" /><link rel="chapter" href="cypher-intro.html" title="Chapter 10. Introduction" /><link rel="chapter" href="query-syntax.html" title="Chapter 11. Syntax" /><link rel="chapter" href="query-read.html" title="Chapter 12. Reading Clauses" /><link rel="chapter" href="query-write.html" title="Chapter 13. Writing Clauses" /><link rel="chapter" href="query-function.html" title="Chapter 14. Functions" /><link rel="chapter" href="examples-from-sql-to-cypher.html" title="Chapter 15. From SQL to Cypher" /><link rel="part" href="reference-documentation.html" title="Part IV. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 16. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 17. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 18. Data Import" /><link rel="chapter" href="indexing.html" title="Chapter 19. Indexing" /><link rel="chapter" href="graph-algo.html" title="Chapter 20. Graph Algorithms" /><link rel="chapter" href="server.html" title="Chapter 21. Neo4j Server" /><link rel="chapter" href="rest-api.html" title="Chapter 22. REST API" /><link rel="chapter" href="deprecations.html" title="Chapter 23. Deprecations" /><link rel="part" href="operations.html" title="Part V. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 24. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 25. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 26. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 27. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 28. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 29. Monitoring" /><link rel="part" href="tools.html" title="Part VI. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 30. Web Interface" /><link rel="chapter" href="shell.html" title="Chapter 31. Neo4j Shell" /><link rel="part" href="community.html" title="Part VII. Community" /><link rel="chapter" href="community-support.html" title="Chapter 32. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 33. Contributing to Neo4j" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-shell" /><link rel="refentry" href="re03.html" title="neo4j-backup" /><link rel="refentry" href="re04.html" title="neo4j-arbiter" /><link rel="subsection" href="introduction-pattern.html#_patterns_for_related_nodes" title="11.5.1. Patterns for related nodes" /><link rel="subsection" href="introduction-pattern.html#_working_with_relationships" title="11.5.2. Working with relationships" /><link rel="subsection" href="introduction-pattern.html#_optional_relationships" title="11.5.3. Optional relationships" /><link rel="subsection" href="introduction-pattern.html#_controlling_depth" title="11.5.4. Controlling depth" /><link rel="subsection" href="introduction-pattern.html#_assigning_to_path_identifiers" title="11.5.5. Assigning to path identifiers" /><link rel="subsection" href="introduction-pattern.html#_setting_properties" title="11.5.6. Setting properties" /><link rel="copyright" href="ln-idp1112768.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>
<script type="text/javascript" src="js/shBrushProperties.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="cypher-query-lang.html">Cypher Query Language</a></span> &gt; <span class="breadcrumb-link"><a href="query-syntax.html">Syntax</a></span> &gt; <span class="breadcrumb-node">Patterns</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="cypher-comments.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="query-read.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="introduction-pattern"></a>11.5. Patterns</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="introduction-pattern.html#_patterns_for_related_nodes">11.5.1. Patterns for related nodes</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_working_with_relationships">11.5.2. Working with relationships</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_optional_relationships">11.5.3. Optional relationships</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_controlling_depth">11.5.4. Controlling depth</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_assigning_to_path_identifiers">11.5.5. Assigning to path identifiers</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_setting_properties">11.5.6. Setting properties</a></span></dt></dl></div><p>Patterns and pattern-matching are at the very heart of Cypher, and so it’s very important to understand patterns,
to be able to be effective with Cypher.</p><p>For instance, using patterns, you describe the shape of the data you’re looking for in the <code class="literal">MATCH</code> clause. You describe
the pattern, and Cypher will figure out how to get that data for you. The idea is for you to draw your
query on a whiteboard, naming the interesting parts of the pattern, so you can then use values from these parts
to create the result set you are looking for.</p><p>Patterns have bound points, or starting points. They are the parts of the pattern that are already “bound” to a set of
graph nodes or relationships. All parts of the pattern must be directly or indirectly connected to a starting point — a pattern
where parts of the pattern are not reachable from any starting point will be rejected.</p><div class="informaltable"><table cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /></colgroup><thead><tr><th align="right" valign="top">Clause</th><th align="center" valign="top">Optional</th><th align="center" valign="top">Multiple rel. types</th><th align="center" valign="top">Varlength</th><th align="center" valign="top">Paths</th><th align="center" valign="top">Maps</th></tr></thead><tbody><tr><td align="right" valign="top"><p><span class="strong"><strong>Match</strong></span></p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>-</p></td></tr><tr><td align="right" valign="top"><p><span class="strong"><strong>Create</strong></span></p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>Yes</p></td></tr><tr><td align="right" valign="top"><p><span class="strong"><strong>Create Unique</strong></span></p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>Yes</p></td></tr><tr><td align="right" valign="top"><p><span class="strong"><strong>Expressions</strong></span></p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>Yes</p></td><td align="center" valign="top"><p>-</p></td><td align="center" valign="top"><p>-</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_patterns_for_related_nodes"></a>11.5.1. Patterns for related nodes</h3></div></div></div><p>The description of the pattern is made up of one or more paths, separated by commas. A path is a sequence of nodes and
relationships that always start and end in nodes. An example path would be:</p><p><code class="literal"><code class="literal">(a)--&gt;(b)</code></code></p><p>This is a path starting from the pattern node <code class="literal">a</code>, with an outgoing relationship from it to pattern node <code class="literal">b</code>.</p><p>Paths can be of arbitrary length, and the same node may appear in multiple places in the path. Path patterns are
expressions, and since these expressions are collections, they can also be used as predicates (where a non-empty
collection signifies true).</p><p>Node identifiers can be used with or without surrounding parenthesis. The following match is semantically identical to
the one we saw above — the difference is purely aesthetic.</p><p><code class="literal"><code class="literal">a--&gt;b</code></code></p><p>If you don’t care about a node, you don’t need to name it. Empty parenthesis are used for these nodes, like so:</p><p><code class="literal"><code class="literal">a--&gt;()&lt;--b</code></code></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_working_with_relationships"></a>11.5.2. Working with relationships</h3></div></div></div><p>If you need to work with the relationship between two nodes, you can name it.</p><p><code class="literal"><code class="literal">a-[r]-&gt;b</code></code></p><p>If you don’t care about the direction of the relationship, you can omit the arrow at either end of the relationship, like this:</p><p><code class="literal"><code class="literal">a--b</code></code></p><p>Relationships have types. When you are only interested in a specific relationship type, you can specify this like so:</p><p><code class="literal"><code class="literal">a-[:REL_TYPE]-&gt;b</code></code></p><p>If multiple relationship types are acceptable, you can list them, separating them with the pipe symbol <code class="literal">|</code> like this:</p><p><code class="literal"><code class="literal">a-[r:TYPE1|TYPE2]-&gt;b</code></code></p><p>This pattern matches a relationship of type <code class="literal">TYPE1</code> or <code class="literal">TYPE2</code>, going from <code class="literal">a</code> to <code class="literal">b</code>. The relationship is named <code class="literal">r</code>.
Multiple relationship types can not be used with <code class="literal">CREATE</code> or <code class="literal">CREATE UNIQUE</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_optional_relationships"></a>11.5.3. Optional relationships</h3></div></div></div><p>An optional relationship is matched when it is found, but replaced by a <code class="literal">null</code> otherwise.
Normally, if no matching relationship is found, that sub-graph is not matched.
Optional relationships could be considered the Cypher equivalent of the outer join in SQL
and can only be used in a <code class="literal">MATCH</code> clause.</p><p>Optional relationships are marked with a question mark.
They allow you to write queries like this one:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START me=node(*)
MATCH me--&gt;friend-[?]-&gt;friend_of_friend
RETURN friend, friend_of_friend</pre><p>
</p><p>The query above says “for every person, give me all their friends, and their friends friends, if they have any.”</p><p>Optionality is transitive — if a part of the pattern can only be reached from a bound point through an optional relationship,
that part is also optional. In the pattern above, the only bound point in the pattern is <code class="literal">me</code>. Since the relationship
between <code class="literal">friend</code> and <code class="literal">children</code> is optional, <code class="literal">children</code> is an optional part of the graph.</p><p>Also, named paths that contain optional parts are also optional — if any part of the path is
<code class="literal">null</code>, the whole path is <code class="literal">null</code>.</p><p>In the following examples, <code class="literal">b</code> and <code class="literal">p</code> are all optional and can contain <code class="literal">null</code>:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START a=node(4)
MATCH p = a-[?]-&gt;b
RETURN b</pre><p>
</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START a=node(4)
MATCH p = a-[?*]-&gt;b
RETURN b</pre><p>
</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START a=node(4)
MATCH p = a-[?]-&gt;x--&gt;b
RETURN b</pre><p>
</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START a=node(4), x=node(3)
MATCH p = shortestPath( a-[?*]-&gt;x )
RETURN p</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_controlling_depth"></a>11.5.4. Controlling depth</h3></div></div></div><p>A pattern relationship can span multiple graph relationships. These are called variable length relationships, and are
marked as such using an asterisk (<code class="literal">*</code>):</p><p><code class="literal"><code class="literal">(a)-[*]-&gt;(b)</code></code></p><p>This signifies a path starting on the pattern node <code class="literal">a</code>, following only outgoing relationships, until it reaches pattern
node <code class="literal">b</code>. Any number of relationships can be followed searching for a path to <code class="literal">b</code>, so this can be a very expensive query,
depending on what your graph looks like.</p><p>You can set a minimum set of steps that can be taken, and/or the maximum number of steps:</p><p><code class="literal"><code class="literal">(a)-[*3..5]-&gt;(b)</code></code></p><p>This is a variable length relationship containing at least three graph relationships, and at most five.</p><p>Variable length relationships can not be used with <code class="literal">CREATE</code> and <code class="literal">CREATE UNIQUE</code>.</p><p>As a simple example, let’s take the query below:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START me=node(3)
MATCH me-[:KNOWS*1..2]-remote_friend
RETURN remote_friend</pre><p>
</p><div class="queryresult table"><a id="idp7931184"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">remote_friend</th></tr></thead><tfoot><tr><th align="left" valign="top">0 row</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /><p>This query starts from one node, and follows <code class="literal">KNOWS</code> relationships two or three steps out, and then stops.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_assigning_to_path_identifiers"></a>11.5.5. Assigning to path identifiers</h3></div></div></div><p>In a graph database, a path is a very important concept. A path is a collection of nodes and relationships,
that describe a path in the graph. To assign a path to a path identifier, you simply assign a path pattern to an
identifier, like so:</p><p><code class="literal"><code class="literal">p = (a)-[*3..5]-&gt;(b)</code></code></p><p>You can do this in <code class="literal">MATCH</code>, <code class="literal">CREATE</code> and <code class="literal">CREATE UNIQUE</code>, but not when using patterns as expressions. Example of the
three in a single query:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">START me=node(3)
MATCH p1 = me-[*2]-friendOfFriend
CREATE p2 = me-[:MARRIED_TO]-(wife {name:"Gunhild"})
CREATE UNIQUE p3 = wife-[:KNOWS]-friendOfFriend
RETURN p1,p2,p3</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_setting_properties"></a>11.5.6. Setting properties</h3></div></div></div><p>Nodes and relationships are important, but Neo4j uses properties on both of these to allow for far richer graph models.</p><p>Properties are expressed in patterns using a map-construct, simply curly brackets surrounding a number of
key-expression pairs, separated by commas, e.g. <code class="literal">{ name: "Andres", sport: "Brazilian Ju-Jitsu" }</code>. If the map is supplied through a
parameter, the normal parameter expression is used: <code class="literal">{ paramName }</code>.</p><p>Patterns are also used to mutate the graph with <code class="literal">CREATE</code> and <code class="literal">CREATE UNIQUE</code>. Maps are only used by <code class="literal">CREATE</code> and
<code class="literal">CREATE UNIQUE</code>. In <code class="literal">CREATE</code> they are used to set the properties on the newly created nodes and relationships. When
used with <code class="literal">CREATE UNIQUE</code>, they are used to try to match a pattern element with the corresponding graph element.
The match is successful if the properties on the pattern element can be matched exactly against properties on the graph
elements. The graph element can have additional properties, and they do not affect the match. If Neo4j fails to find
matching graph elements, the maps is used to set the properties on the newly created elements.</p></div></div><HR xmlns=""></HR><a xmlns="" href="ln-idp1112768.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2014 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="cypher-comments.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="query-syntax.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="query-read.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
